[{"title":"关于求职的一些想法","date":"2023-02-16T08:23:44.000Z","path":"2023/02/16/关于求职的一些想法/","text":"","tags":[]},{"title":"Hello World","date":"2023-02-16T02:34:05.806Z","path":"2023/02/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"Slf4j源码浅析","date":"2019-05-30T17:03:50.000Z","path":"2019/05/31/Slf4j源码浅析/","text":"问题复现在项目中引入一个二方包后在后台日志诡异的不见了，于是使用 mvn dependency:tree -l tree.txt 输出依赖关系树，并定位到新引入的二方包部分,二方包引入了spring-boot-starter-logging其依赖了logback-classic与项目中的log4j产生了冲突，所以将前者排掉就项目就可以正常启动了，这个排包的过程不算难，那slf4j是如何实现绑定的呢？ slf4j源码浅析这里使用到的slf4j-api版本是1.7.25，在老版本中是存在一些线程安全问题的，通常我们打日志的时候都会写一段这样的代码 1private static final Logger logger = LoggerFactory.getLogger(XXX.class) 我们从LoggerFactory这个类开始分析源码,首先看到getLogger方法 12345678public static Logger getLogger(Class&lt;?&gt; clazz) &#123; Logger logger = getLogger(clazz.getName()); .....&#125;public static Logger getLogger(String name) &#123; ILoggerFactory iLoggerFactory = getILoggerFactory(); return iLoggerFactory.getLogger(name);&#125; 从上面源码可以看到会调用getLogger(String name)这个方法，通过LoggerFactory最终获取Logger对象，所以重点就是获取LoggerFactory. 我们重点看下 getILoggerFactory这个方法 1234567891011121314151617181920212223 public static ILoggerFactory getILoggerFactory() &#123; if (INITIALIZATION_STATE == UNINITIALIZED) &#123; synchronized (LoggerFactory.class) &#123; if (INITIALIZATION_STATE == UNINITIALIZED) &#123; INITIALIZATION_STATE = ONGOING_INITIALIZATION; performInitialization(); &#125; &#125; &#125; switch (INITIALIZATION_STATE) &#123; case SUCCESSFUL_INITIALIZATION: return StaticLoggerBinder.getSingleton().getLoggerFactory(); case NOP_FALLBACK_INITIALIZATION: return NOP_FALLBACK_FACTORY; case FAILED_INITIALIZATION: throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG); case ONGOING_INITIALIZATION: // support re-entrant behavior. // See also http://jira.qos.ch/browse/SLF4J-97 return SUBST_FACTORY; &#125; throw new IllegalStateException(\"Unreachable code\");&#125; 从源码中可以看到INITIALIZATION_STATE是一个静态的volatile变量，在之前的版本中没有volatile修饰，在这个方法中主要就是调用了performInitialization方法完成初始化,在该方法中主要完成绑定工作并进行检查 123456789101112131415161718192021222324private final static void performInitialization() &#123; bind(); if (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123; versionSanityCheck(); &#125; &#125; private final static void bind() &#123; try &#123; Set&lt;URL&gt; staticLoggerBinderPathSet = null; if (!isAndroid()) &#123; staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet(); reportMultipleBindingAmbiguity(staticLoggerBinderPathSet); &#125; // the next line does the binding StaticLoggerBinder.getSingleton(); INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION; reportActualBinding(staticLoggerBinderPathSet); fixSubstituteLoggers(); replayEvents(); // release all resources in SUBST_FACTORY SUBST_FACTORY.clear(); &#125; ... 其中有个重要的方法findPossibleStaticLoggerBinderPathSet 顾名思义就是找可能存在的StaticLoggerBinder路径 1234567891011121314151617181920212223private static String STATIC_LOGGER_BINDER_PATH = \"org/slf4j/impl/StaticLoggerBinder.class\"; static Set&lt;URL&gt; findPossibleStaticLoggerBinderPathSet() &#123; // use Set instead of list in order to deal with bug #138 // LinkedHashSet appropriate here because it preserves insertion order // during iteration Set&lt;URL&gt; staticLoggerBinderPathSet = new LinkedHashSet&lt;URL&gt;(); try &#123; ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader(); Enumeration&lt;URL&gt; paths; if (loggerFactoryClassLoader == null) &#123; paths = ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH); &#125; else &#123; paths = loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH); &#125; while (paths.hasMoreElements()) &#123; URL path = paths.nextElement(); staticLoggerBinderPathSet.add(path); &#125; &#125; ... return staticLoggerBinderPathSet; &#125; 其实就是找日志实现包中的的StaticLoggerBinder，如slf4j-log4j12中的，将这些类的类路径添加到上面的set中，接着通过reportMultipleBindingAmbiguity方法检查是不是存在多个日志实现绑定产生冲突, 即看一下binderPathSet中元素个数是不是大于1，很简单，因此当项目中logback和slf4j-log4j同时存在时会打印出多个”Found binding in …” 12345678910111213private static boolean isAmbiguousStaticLoggerBinderPathSet(Set&lt;URL&gt; binderPathSet) &#123; return binderPathSet.size() &gt; 1; &#125; private static void reportMultipleBindingAmbiguity(Set&lt;URL&gt; binderPathSet) &#123; if (isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) &#123; Util.report(\"Class path contains multiple SLF4J bindings.\"); for (URL path : binderPathSet) &#123; Util.report(\"Found binding in [\" + path + \"]\"); &#125; Util.report(\"See \" + MULTIPLE_BINDINGS_URL + \" for an explanation.\"); &#125; &#125; 回到bind方法，看到StaticLoggerBinder.getSingleton();，其实就是创建一个单例的StaticLoggerBinder对象，而这个对象中含有一个LoggerFactory，针对不同的日志框架有不同的实现 log4j1234567891011private final ILoggerFactory loggerFactory;private StaticLoggerBinder() &#123; loggerFactory = new Log4jLoggerFactory(); try &#123; Level level = Level.TRACE; &#125; catch (NoSuchFieldError nsfe) &#123; Util .report(\"This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version\"); &#125;&#125; logback-classic1234567private boolean initialized = false;private LoggerContext defaultLoggerContext = new LoggerContext();private final ContextSelectorStaticBinder contextSelectorBinder = ContextSelectorStaticBinder.getSingleton();private StaticLoggerBinder() &#123; defaultLoggerContext.setName(CoreConstants.DEFAULT_CONTEXT_NAME);&#125; 通过这种绑定的方式就可以实现LoggerFactory的获取，如引入了log4j，就会利用log4j实现的StaticLoggerBinder类来获取log4j的LoggerFactory,而LoggerFactory可以简单地理解为一个Map，key为loggerName,value为Logger对象","tags":[{"name":"Java","slug":"Java","permalink":"https://xiaoysec.github.io/tags/Java/"},{"name":"slf4j","slug":"slf4j","permalink":"https://xiaoysec.github.io/tags/slf4j/"}]}]